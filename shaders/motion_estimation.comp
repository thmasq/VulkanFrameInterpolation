#version 450
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types : require

// Motion estimation using block matching with Sum of Absolute Differences (SAD)
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Input textures
layout(set = 0, binding = 0) uniform sampler2D previousFrame;
layout(set = 0, binding = 1) uniform sampler2D currentFrame;
layout(set = 0, binding = 2, rg16f) uniform writeonly image2D motionVectorField;

// Constants buffer
layout(set = 0, binding = 3) uniform MotionEstimationConstants {
    ivec2 frameSize;
    ivec2 blockSize;
    int searchRadius;
    float sadThreshold;
    float confidenceThreshold;
    int qualityLevel;
    float subpixelAccuracy;
    int _padding;
} constants;

// Shared memory for block processing
shared float sharedPrevBlock[18][18];  // 8x8 + 2*searchRadius border
shared float sharedCurrBlock[10][10];  // 8x8 + 1 border

// Convert RGB to luminance for better motion detection
float rgbToLuma(vec3 color) {
    return dot(color, vec3(0.299, 0.587, 0.114));
}

// Load blocks into shared memory
void loadBlocks() {
    ivec2 blockStart = ivec2(gl_WorkGroupID.xy) * constants.blockSize;
    ivec2 localCoord = ivec2(gl_LocalInvocationID.xy);
    
    // Load previous frame block with extended search area
    for (uint i = 0; i < 81; i++) {  // 9x9 iterations to cover 18x18 area
        if (i >= gl_LocalInvocationIndex) break;
        
        uint flatIndex = gl_LocalInvocationIndex * 81 + i;
        if (flatIndex >= 324) break;  // 18*18 = 324
        
        ivec2 sharedCoord = ivec2(flatIndex % 18, flatIndex / 18);
        ivec2 globalCoord = blockStart + sharedCoord - constants.searchRadius - 1;
        
        vec2 uv = (vec2(globalCoord) + 0.5) / vec2(constants.frameSize);
        vec3 color = texture(previousFrame, uv).rgb;
        sharedPrevBlock[sharedCoord.y][sharedCoord.x] = rgbToLuma(color);
    }
    
    // Load current block
    if (all(lessThan(gl_LocalInvocationID.xy, constants.blockSize))) {
        ivec2 globalCoord = blockStart + ivec2(gl_LocalInvocationID.xy);
        vec2 uv = (vec2(globalCoord) + 0.5) / vec2(constants.frameSize);
        vec3 color = texture(currentFrame, uv).rgb;
        sharedCurrBlock[gl_LocalInvocationID.y][gl_LocalInvocationID.x] = rgbToLuma(color);
    }
    
    barrier();
}

// Calculate SAD for a block
float calculateSAD(ivec2 offset) {
    float sad = 0.0;
    
    // Only thread 0 in each work group calculates SAD
    if (gl_LocalInvocationID.x == 0 && gl_LocalInvocationID.y == 0) {
        for (uint y = 0; y < constants.blockSize.y; y++) {
            for (uint x = 0; x < constants.blockSize.x; x++) {
                float curr = sharedCurrBlock[y][x];
                float prev = sharedPrevBlock[y + offset.y + constants.searchRadius]
                                           [x + offset.x + constants.searchRadius];
                sad += abs(curr - prev);
            }
        }
    }
    
    return sad;
}

// Subpixel refinement using parabolic fitting
vec2 refineSubpixel(vec2 bestOffset, float centerSAD, float leftSAD, float rightSAD, 
                    float topSAD, float bottomSAD) {
    vec2 refined = bestOffset;
    
    // Horizontal refinement
    if (leftSAD < 999999.0 && rightSAD < 999999.0) {
        float denom = 2.0 * (leftSAD - 2.0 * centerSAD + rightSAD);
        if (abs(denom) > 0.0001) {
            refined.x += (leftSAD - rightSAD) / denom;
        }
    }
    
    // Vertical refinement
    if (topSAD < 999999.0 && bottomSAD < 999999.0) {
        float denom = 2.0 * (topSAD - 2.0 * centerSAD + bottomSAD);
        if (abs(denom) > 0.0001) {
            refined.y += (topSAD - bottomSAD) / denom;
        }
    }
    
    return refined;
}

// Hierarchical block matching for better accuracy
vec2 hierarchicalSearch(ivec2 blockStart) {
    vec2 bestOffset = vec2(0.0);
    float bestSAD = 999999.0;
    
    // Coarse search with step size 2
    int step = 2;
    for (int dy = -constants.searchRadius; dy <= constants.searchRadius; dy += step) {
        for (int dx = -constants.searchRadius; dx <= constants.searchRadius; dx += step) {
            ivec2 offset = ivec2(dx, dy);
            float sad = calculateSAD(offset);
            
            if (sad < bestSAD) {
                bestSAD = sad;
                bestOffset = vec2(offset);
            }
        }
    }
    
    // Fine search around best coarse result
    vec2 fineOffset = bestOffset;
    float fineSAD = bestSAD;
    
    for (int dy = -step; dy <= step; dy++) {
        for (int dx = -step; dx <= step; dx++) {
            ivec2 offset = ivec2(bestOffset) + ivec2(dx, dy);
            
            // Bounds check
            if (any(lessThan(offset, ivec2(-constants.searchRadius))) ||
                any(greaterThan(offset, ivec2(constants.searchRadius)))) {
                continue;
            }
            
            float sad = calculateSAD(offset);
            if (sad < fineSAD) {
                fineSAD = sad;
                fineOffset = vec2(offset);
            }
        }
    }
    
    // Subpixel refinement if enabled
    if (constants.subpixelAccuracy > 0.5) {
        ivec2 iOffset = ivec2(fineOffset);
        
        // Sample neighboring SAD values for interpolation
        float leftSAD = (iOffset.x > -constants.searchRadius) ? 
                       calculateSAD(iOffset + ivec2(-1, 0)) : 999999.0;
        float rightSAD = (iOffset.x < constants.searchRadius) ? 
                        calculateSAD(iOffset + ivec2(1, 0)) : 999999.0;
        float topSAD = (iOffset.y > -constants.searchRadius) ? 
                      calculateSAD(iOffset + ivec2(0, -1)) : 999999.0;
        float bottomSAD = (iOffset.y < constants.searchRadius) ? 
                         calculateSAD(iOffset + ivec2(0, 1)) : 999999.0;
        
        fineOffset = refineSubpixel(fineOffset, fineSAD, leftSAD, rightSAD, topSAD, bottomSAD);
    }
    
    return fineOffset;
}

// Calculate motion vector confidence based on SAD ratio
float calculateConfidence(float bestSAD, float secondBestSAD) {
    if (secondBestSAD < 0.0001) return 0.0;
    return 1.0 - (bestSAD / secondBestSAD);
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    
    // Early exit for out-of-bounds
    if (any(greaterThanEqual(pixelCoord, constants.frameSize))) {
        return;
    }
    
    // Only process on block boundaries
    if (any(notEqual(pixelCoord % constants.blockSize, ivec2(0)))) {
        return;
    }
    
    // Load blocks into shared memory
    loadBlocks();
    
    // Perform motion estimation
    vec2 motionVector = vec2(0.0);
    
    if (gl_LocalInvocationID.x == 0 && gl_LocalInvocationID.y == 0) {
        ivec2 blockStart = ivec2(gl_WorkGroupID.xy) * constants.blockSize;
        
        if (constants.qualityLevel >= 2) {
            // High quality: hierarchical search
            motionVector = hierarchicalSearch(blockStart);
        } else {
            // Standard quality: simple full search
            float bestSAD = 999999.0;
            
            for (int dy = -constants.searchRadius; dy <= constants.searchRadius; dy++) {
                for (int dx = -constants.searchRadius; dx <= constants.searchRadius; dx++) {
                    ivec2 offset = ivec2(dx, dy);
                    float sad = calculateSAD(offset);
                    
                    if (sad < bestSAD) {
                        bestSAD = sad;
                        motionVector = vec2(offset);
                    }
                }
            }
        }
    }
    
    // Broadcast result to all threads in workgroup
    barrier();
    
    // Write motion vector for each pixel in the block
    for (uint y = 0; y < constants.blockSize.y; y++) {
        for (uint x = 0; x < constants.blockSize.x; x++) {
            ivec2 writeCoord = ivec2(gl_WorkGroupID.xy) * constants.blockSize + ivec2(x, y);
            if (all(lessThan(writeCoord, constants.frameSize))) {
                imageStore(motionVectorField, writeCoord, vec4(motionVector, 0.0, 1.0));
            }
        }
    }
}
